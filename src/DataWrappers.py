# -*- coding: utf-8 -*-
"""DataWrappers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16Hj8vFFsq-8AzTCetKDhZqcbg_1_qYo_
"""

import os
import random
import numpy as np
import torch
from torch.utils.data import Dataset, ConcatDataset

from skimage.morphology import dilation, star
from PIL import Image

import matplotlib.pyplot as plt

class RandomDataset(torch.utils.data.Dataset):
    
    """
      Generate Dataset from randomly cropped samples from given images
      
      Args:
            images_dir: path to directory with images
            masks_dir: path to directory with masks
            img_transform, mask_transform: function for sample transformation
            sample_size: spatial resolution of sample in pixels (height, width)
            dil: structuring element for mask dilation
    """

    def __init__(self, images_dir, masks_dir, img_transform,mask_transform, test=False, 
                 sample_size=(1024,1024), dil=star(0), inv=False, preprocessing_fn=None):

        self.images_dir = images_dir
        self.masks_dir = masks_dir
        self.images_titles = sorted(os.listdir(self.images_dir))
        self.masks_titles = sorted(os.listdir(self.masks_dir))
        self.img_transform = img_transform
        self.mask_transform = mask_transform
        self.preprocessing_fn = preprocessing_fn
        self.sample_size = sample_size
        self.test = test
        self.dil = dil
        self.inv = inv
        
    def __len__(self):
        return len(self.images_titles)

    def add_border(self, img):
        old_size = img.size

        new_size = ((int(old_size[0] / self.sample_size[0]) + 1)*self.sample_size[0], 
                    (int(old_size[1] / self.sample_size[1]) + 1)*self.sample_size[1])
        
        new_img = Image.new(img.mode, new_size, 0)
        new_img.paste(img, (int((new_size[0]-old_size[0])/2),
                            int((new_size[1]-old_size[1])/2)))
        
        return new_img

    def __getitem__(self, idx):

        image = Image.open(os.path.join(self.images_dir, self.images_titles[idx]))
        mask = Image.open(os.path.join(self.masks_dir, self.masks_titles[idx]))
        if self.test:
            mask = dilation(mask, self.dil)
            return image, mask

        if self.inv:
          image = image.resize((int(image.size[0]/3), int(image.size[1] /3)))
          mask = mask.resize((int(mask.size[0]/3), int(mask.size[1] /3)))
          mask = ImageOps.invert(mask)

        h, w = self.sample_size
        if image.size[0] < h or image.size[1] < w:
            image = self.add_border(image)
            mask = self.add_border(mask)
        
        x_range = max(10, image.size[0] - w)
        y_range = max(10, image.size[1] - h)

        x = np.random.randint(x_range)
        y = np.random.randint(y_range)

        image = image.crop((x, y, x+h, y+w))
        mask = mask.crop((x, y, x+h, y+w))
          
        
        seed = random.randint(0, 100)
        random.seed(seed)
        torch.manual_seed(seed)
        sample = self.img_transform(image=np.array(image), mask=np.array(mask))
        image, mask = sample['image'], sample['mask']
        if len(mask.shape) == 3:
          mask = mask[:,:,1]

        mask = dilation(mask, self.dil)

        #random.seed(seed)
        #torch.manual_seed(seed)
        #mask = self.mask_transform(image=np.array(mask,dtype=np.uint8))['image']
        mask[mask != 0] = 1
        if self.preprocessing_fn:
            image = preprocessing_fn(image)
        image = np.transpose(image, (2,0,1))
        mask = mask.reshape(1,mask.shape[0],mask.shape[1])

        return torch.tensor(image), torch.tensor(mask)

    
def visualize_dataset(dataset, img_num=6):
    fig, ax = plt.subplots(2,img_num, figsize = (20,7))
    i = 0 
    for x, y in dataset:
        #print(x.shape, x.float().mean())
        #print(y.shape, y.float().mean())

        image = torchvision.transforms.functional.to_pil_image(x)
        outline = torchvision.transforms.functional.to_pil_image(y)

        ax[0,i].imshow(image)
        ax[1,i].imshow(outline)
        i += 1
        if i == img_num: break
    plt.show()


def add_mask(img, mask):
  img = np.array(img)
  mask = np.array(mask)
  img[:,:,0] = mask*255
  return img

